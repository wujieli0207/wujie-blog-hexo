<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/25/hello-world/</url>
    <content><![CDATA[<p>Hey wujie, 这是你发布在网络上的第一篇博客，希望你不忘初心，无限进步</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3个人常用通信方式总结</title>
    <url>/2021/12/06/vue3%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul>
<li><p>Vue3 子组件可以通过 props 接受父组件的传值</p>
</li>
<li><p>在 setup() 中可以通过 <code>props.value</code> 来访问父组件传值</p>
</li>
<li><p>父组件传值举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child-component :value=&quot;value&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件接受并使用父组件传递值</p>
<span id="more"></span>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&#123;&#123; fatherValue &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;ChildComponent&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const fatherValue = ref(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            fatherValue = props.value</span><br><span class="line">            console.log( fatherValue )</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                fatherValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2></li>
<li><p>通过 refs ，父组件可以直接获取子组件实例，并向子组件传值</p>
</li>
<li><p>父组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child ref=&quot;childRef&quot; /&gt;</span><br><span class="line">	&lt;button @click=&quot;sendValue()&quot;&gt;</span><br><span class="line">        Change Child Value</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;ChildComponent&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const childRef = ref(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            const sendValue = () =&gt; &#123;</span><br><span class="line">                console.log(&quot;childRef&quot;, childRef.value);</span><br><span class="line"></span><br><span class="line">                // 调用子组件方法</span><br><span class="line">                childRef.value.acceptValue(&quot;newValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                fatherValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	Son: &#123;&#123; valueRef &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;ChildComponent&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const valueRef = ref(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            const acceptValue = (value) =&gt; &#123;</span><br><span class="line">            	valueRef.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                valueRef,</span><br><span class="line">                acceptValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="emits"><a href="#emits" class="headerlink" title="emits"></a>emits</h2><ul>
<li><p>子组件可以通过 emit 暴露属性，父组件通过 emit 暴露属性操作子组件，比如：点击子组件触发了一个父组件大函数</p>
</li>
<li><p>父亲组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child-component :add-child=&quot;addChildMethod()&quot;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;FatherComponent&quot;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const addChildMethod = () =&gt; &#123;</span><br><span class="line">                // mehtod</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;</span><br><span class="line">                addChildMethod</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div @click=&quot;$emit(&#x27;addChild&#x27;)&quot;&gt;</span><br><span class="line">        &lt;!-- some --&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack入门-loader</title>
    <url>/2021/12/05/webpack%E5%85%A5%E9%97%A8-loader/</url>
    <content><![CDATA[<h2 id="loader-基础"><a href="#loader-基础" class="headerlink" title="loader 基础"></a>loader 基础</h2><ul>
<li><p>将所有文件转换成 webpack 能够处理的模块，用于处理非 JS 文件</p>
</li>
<li><p>在 module.rule 配置，必须包含 test 和 use 属性</p>
<ul>
<li><code>test</code>： 标识出应该被对应的 loader 进行转换的某个或某些文件</li>
<li><code>use</code>：进行转换时，应该使用哪个 loader<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">	<span class="attr">rules</span>: [</span><br><span class="line">	  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: <span class="string">&#x27;css-loader&#x27;</span> &#125;,</span><br><span class="line">	  &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, use: <span class="string">&#x27;ts-loader&#x27;</span> &#125;</span><br><span class="line">	]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用 loader 的三种方式</p>
<ul>
<li>配置（推荐）：在 webpack.config.js 中配置</li>
<li>内联：在每个 import 语句中显式指定 loader<br>  <code>import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;;</code></li>
<li>CLI：在 shell 命令中指定它们<br>  <code>webpack --module-bind jade-loader --module-bind &#39;css=style-loader!css-loader&#39;</code></li>
</ul>
</li>
<li><p>loader 特性</p>
<ul>
<li>loader 支持链式传递，反向执行，loader 链中的第一个 loader 返回值给下一个 loader</li>
<li>loader 可同步也可异步</li>
<li>loader 可以在 Node.js 环境运行</li>
<li>loader 能够接受查询参数</li>
<li>loader 可以使用 <code>opotions</code> 对象进行配置</li>
<li>可以将普通 npm 模块导出一个 loader</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack入门-入口与出口</title>
    <url>/2021/12/02/webpack%E5%85%A5%E9%97%A8-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="入口及基础配置"><a href="#入口及基础配置" class="headerlink" title="入口及基础配置"></a>入口及基础配置</h2><ul>
<li>webpack 该用哪个模块作为构建依赖图的开始</li>
<li>在 <code>entry</code> 配置入口，可以指定一个或多个入口  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>单页面场景配置<ul>
<li>将应用入口和第三方库分离</li>
<li>可以使用 <code>CommonsChunkPlugin</code>  从「应用程序 bundle」中提取 vendor 引用到 vendor bundle，把引用 vendor 的部分替换为 ，<code>__webpack_require__()</code> 调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">	<span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">	<span class="attr">vendors</span>: <span class="string">&#x27;./src/vendors.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>多页面场景配置<ul>
<li>不同页面入口分开配置，进入新页面时独立加载 html 和对应引用</li>
<li>可以使用 <code>CommonsChunkPlugin</code> 为每个页面间的应用程序共享代码创建 bundle，实现代码复用的效果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">	<span class="attr">pageOne</span>: <span class="string">&#x27;./src/pageOne/index.js&#x27;</span>,</span><br><span class="line">	<span class="attr">pageTwo</span>: <span class="string">&#x27;./src/pageTwo/index.js&#x27;</span>,</span><br><span class="line">	<span class="attr">pageThree</span>: <span class="string">&#x27;./src/pageThree/index.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="出口及基础配置"><a href="#出口及基础配置" class="headerlink" title="出口及基础配置"></a>出口及基础配置</h2><ul>
<li><p>webpack 输出 bundles 的目录及命名方式配置，默认为  <code>./dist</code></p>
</li>
<li><p><strong>可以指定多个入口，但只能有一个出口（output）</strong></p>
</li>
<li><p>在 <code>output</code> 字段配置：输出为一个对象，输出路径和文件名</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">	<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">	<span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>对于多文件入口，使用占位符保持文件名正确</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">	<span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">	<span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">	<span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure></li>
<li><p>在编译时不知道最终输出文件的 <code>publicPath</code> 的情况下，<code>publicPath</code> 留空，并且在入口起点设置 <code>__webpack_public_path__</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余的应用程序入口</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2021年总结</title>
    <url>/2021/12/22/%E6%88%91%E7%9A%842021%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>我是在保险公司工作的程序员，之前做过的项目相对比较简单，或者是采购的产品再定制化开发，而今年算是独立负责了一个部门重点项目，熬了几个月也算是项目正常上线了，尤其是最后一个月，经常加班到凌晨一两点。</p>
<p>在甲方做程序员不像乙方，具体开发写代码主要都是由供应商做的，而主要做的是项目管理和协调一类的工作，缺点是技术方面的进步比较慢，优点是看到的层次更高，不是专注于某个功能的开发，而是会更加偏向业务方面。</p>
<p>但其实说是偏向管理，但很多时候自己也要上手写代码，去改 Bug。而且我觉得其实只是改 Bug 也就还可以接受，但还有另一方面是沟通协调，尤其是跨系统间的沟通协调以及和业务部门的沟通，这种没有正确答案的问题处理起来才最为痛苦。在这次项目中我对接了保险的四个主要渠道部门还有两个产品开发部门，沟通协调确实很考验人，当然学到的东西也非常多。</p>
<p>最后其实还是非常感谢自己的领导和开发同事对这个项目的支持，单凭我一个人肯定是没法完成这个项目的，也希望自己以后能成长为能够有能力独立完成这类项目的人</p>
<h2 id="关于个人成长"><a href="#关于个人成长" class="headerlink" title="关于个人成长"></a>关于个人成长</h2><h3 id="番茄钟学习记录"><a href="#番茄钟学习记录" class="headerlink" title="番茄钟学习记录"></a>番茄钟学习记录</h3><p>我习惯番茄钟记录自己的学习时间，粗略看了一下统计，今年累计学习了 1211 个番茄钟，每个番茄钟 25 分钟，差不多是 21 天的学习时间。看到这个结果确认很感慨，一年有 365 天，真正用于自己学习的时间却不到一个月。</p>
<p><img src="https://notesimgs.oss-cn-shanghai.aliyuncs.com/img/20211222081511.png"><br>每周的番茄钟学习记录</p>
<p>从图表来看我也是从 10 月份才开始真正沉下心来进入学习的状态的，之前一直不知道自己的方向是什么，IT 技术很广泛，什么都想了解一些，但又什么都不够精通。也是从 10 月份开始才逐渐发觉自己的兴趣在前端开发，找到了兴趣点也必然会投入时间学习</p>
<h3 id="从折腾工具到关注产出"><a href="#从折腾工具到关注产出" class="headerlink" title="从折腾工具到关注产出"></a>从折腾工具到关注产出</h3><p>今年我尝试过许多生产力工具软件，单就笔记应用来说，我就尝试过 Typora、印象笔记、语雀、Notion、Wolai、Flomo、Obsidian 还有后来推出的众多双链笔记，有一些浅尝辄止，有一些也确实深度使用过。Notion 和 Flomo 都是我之前使用过的笔记，Notion 功能强大并且有很高的自由度，Flomo 的轻便简洁，我都在这两个应用留下了许多笔记。最后放弃的原因是因为两个应用都需要联网使用，并且数据保存在云端也让我非常不放心。现在逐渐把笔记迁移到了 Obsidian，通过阿里云的 OSS 作为图床，Typera 作功能补充。Obsidian 的更新频率很快，今年也推出了 IOS 端的应用，markdown 所见即所得的功能也在开发当中。</p>
<p>在折腾工具的过程中我逐渐发现一个问题，到底是工具重要，还是如何使用工具重要，现在想想，其实最重要的，是<strong>通过生产力工具产出了什么东西</strong>。用过很多笔记应用，却没有形成自己的知识库体系，也没有内容输出，用过很多 GTD 或者待办事项应用，但该拖延的还是拖延，该关注任务的没有及时关注。所以当把关注点放在了最终产出物和积累上时，工具也没有那么重要了，只要顺手就行了。有了足够多的产出和积累，也就更清楚的了解自己需要的工具是什么了</p>
<h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><h3 id="极简主义和焦虑"><a href="#极简主义和焦虑" class="headerlink" title="极简主义和焦虑"></a>极简主义和焦虑</h3><p>今年阅读了山下英子的《断舍离》，也逐渐了解了极简主义的生活方式，我也开始清理和自己多余的物品并逐渐添置新的物品，我也逐渐形成了自己的购物观念：</p>
<ol>
<li><strong>如无必要，勿增实体</strong></li>
<li><strong>如有必要，尽量选择自己承受范围内做好的</strong></li>
</ol>
<p>第一条是为了避免自己购入不必要的东西，并且要及时清理掉不用的东西。而第二条我觉得才是重点，如果确实是必要的，选择承受范围内最好的可以避免不必要的折腾，就像去年购入的 AirPods Pro 耳机，确实很贵，但购买了这幅耳机之后，我再没有折腾过耳机了</p>
<p>有时候在想自己为什么会产生焦虑，也许就是因为自己的欲望太多，难以填满，而极简主义的思维和生活方式，恰恰就是在对抗这种焦虑，降低自己的欲望，把重心放到重要的事情上面</p>
<h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><p>新的一年，希望自己不再追求知识的广度，而是深入自己领域，追求知识的深度。另一方面希望完善自己的工作方法论和工作流程，积累自己的“知识资本”</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组方法总结</title>
    <url>/2021/12/23/JS-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="数组基础操作"><a href="#数组基础操作" class="headerlink" title="数组基础操作"></a>数组基础操作</h2><ul>
<li>创建数组的方式有两种<ul>
<li><code>new Array()</code></li>
<li><code>[]</code></li>
</ul>
</li>
<li>添加数组<ul>
<li>尾部添加：<code>array.push(item)</code></li>
<li>头部添加：<code>array.unshift(item)</code></li>
<li>直接添加：<code>array[index] = item</code></li>
<li>指定索引位置添加：<code>array.splice(index, 0, item)</code></li>
</ul>
</li>
<li>删除数组<ul>
<li>尾部删除：<code>array.pop(item)</code></li>
<li>头部删除：<code>array.shift(item)</code></li>
<li>指定索引位置删除：<code>array.splice(index, 1)</code></li>
</ul>
</li>
<li>修改数组<ul>
<li>直接通过索引修改：<code>array[index] = item</code></li>
<li>修改指定位置的某一个元素：<code>array.splice(index, 1, item)</code></li>
</ul>
</li>
<li>获取数组长度：<code>array.length</code> （最大的数字索引值 + 1）</li>
</ul>
<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><h3 id="分割与组合方法"><a href="#分割与组合方法" class="headerlink" title="分割与组合方法"></a>分割与组合方法</h3><ul>
<li><p>splice() 方法</p>
<ul>
<li><code>array.splice(index [, deleteCount, item1, item2])</code> 从索引 <code>index</code> 的位置开始删除 <code>deleteCount</code> 个元素，并在当前位置插入 <code>item1, item2</code> 元素，最后返回被处理后的元素数组</li>
<li>常用应用场景<ul>
<li><code>array.splice(index, 1)</code> 从索引位置删除一个元素</li>
<li><code>array.splice(index, 0, item)</code> 在索引位置添加一个元素</li>
</ul>
</li>
</ul>
</li>
<li><p>slice() 方法</p>
<ul>
<li><code>array.slice([start], [end])</code> 创建<strong>一个新数组</strong>，将索引从 <code>start</code> 到 <code>end</code> 的元素复制到新的数组，可以传入负</li>
<li>常用应用场景<ul>
<li><code>array.slice()</code> 获取一个新的数组副本（不影响原数组）</li>
</ul>
</li>
</ul>
</li>
<li><p>concat() 方法</p>
<ul>
<li><code>array.concat(arg1, arg2...)</code> 创建<strong>一个新数组</strong>，将第二个开始的所有参数拼接至第一个数组，第二个开始的参数可以是数组或者值</li>
</ul>
</li>
</ul>
<h3 id="循环数组方法"><a href="#循环数组方法" class="headerlink" title="循环数组方法"></a>循环数组方法</h3><ul>
<li><p><code>for (let i = 0; i &lt; array.length; i++)</code> 速度最快，可以兼容旧版浏览器</p>
</li>
<li><p><code>for (let item of array)</code> 只能获取数组 item</p>
</li>
<li><p><code>for (let key in array)</code> 不建议使用此方法循环数组</p>
<ul>
<li><code>for in</code> 适用于对象循环，并为对象循环做了相关优化，但对数组循环没有优化，循环速度更慢</li>
<li><code>for in</code> 会循环数组的所有属性，在处理“类数组”是没有必要的</li>
</ul>
</li>
<li><p>forEach() 方法</p>
<ul>
<li><code>array.forEach((item, index, array) =&gt; &#123;&#125;)</code> 循环遍历数组，item为元素，index 为索引，array 为被遍历的数组</li>
<li>注意 <strong>forEach 没有返回值</strong></li>
</ul>
</li>
</ul>
<h3 id="查找数组方法"><a href="#查找数组方法" class="headerlink" title="查找数组方法"></a>查找数组方法</h3><ul>
<li><p>indexOf() / lastIndexOf() 方法</p>
<ul>
<li><code>array.indexOf(item, from)</code> 从索引 from 开始查找 item，如果没有找到则返回 -1</li>
<li><code>array.lastIndexOf(item, from)</code> 从索引 from 开始查找 item，查找方向为<strong>从右至左</strong>,如果没有找到则返回 -1</li>
</ul>
</li>
<li><p>includes() 方法</p>
<ul>
<li><code>array.indludes(item, from)</code> 从索引 from 开始查找 item，如果没有找到则<strong>返回 false</strong></li>
<li>检查是否包含某个元素<strong>优先使用 includes()</strong></li>
<li>注：includes() 能够正确识别 NAN</li>
</ul>
</li>
<li><p>find() / findIndex() 方法</p>
<ul>
<li>如果返回为 true，则返回 item 并<strong>停止迭代</strong></li>
<li>如果返回为 false，则返回 undefined</li>
<li>使用场景<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = array.find(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">	item.id === <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>findIndex() 方法返回的是 index ，其余和 find() 方法没有区别</li>
</ul>
</li>
<li><p>filter() 方法</p>
<ul>
<li>返回<strong>所有匹配元素组成的数组</strong><ul>
<li>如果返回为 true，则 item 被放到结果数据，迭代继续直到完成</li>
<li>如果什么都没有找到则返回空数组</li>
</ul>
</li>
<li>使用示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回结果为数组</span></span><br><span class="line"><span class="keyword">let</span> results = array.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">	item.id &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="转换数组方法"><a href="#转换数组方法" class="headerlink" title="转换数组方法"></a>转换数组方法</h3><ul>
<li><p>map() 方法</p>
<ul>
<li>对每个元素都调用函数，<strong>返回一个新的数组</strong></li>
<li>使用示例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> result = array.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">	item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [1, 4, 6]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sort() 方法</p>
<ul>
<li>对当前数组进行排序（<strong>没有生成新数组</strong>）</li>
<li>默认使用字符串排序，如果是<strong>数字排序需要指定参考函数</strong></li>
<li>返回为负数，按照升序排列（<strong>负数表示小于</strong>）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;a - b;&#125;);</span><br></pre></td></tr></table></figure></li>
<li>返回为正数，按照降序排列（上述例子相反，<strong>正数表示大于</strong>）</li>
</ul>
</li>
<li><p>reverse() 方法</p>
<ul>
<li>颠倒元素顺序</li>
</ul>
</li>
<li><p>split() / join() 方法</p>
<ul>
<li><code>array.split(delim, [length])</code> 根据提供的分隔符 delim 将字符串分割成数组，length 用于限制生成数组的长度</li>
<li><code>array.join(delim)</code> 使用分隔符 delim 将数组组成字符串</li>
</ul>
</li>
<li><p>reduce() / reduceRight() 方法</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = array.reduce(<span class="function">(<span class="params">accumulator, item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;, [initial])</span><br></pre></td></tr></table></figure>
<ul>
<li>参数含义<ul>
<li>accumulator：上一个函数调用的结果，第一次等于 initial 参数（如果提供了 initial 参数的话），如果没提供 initial 参数，则以第一个参数作为初始值，从第二个参数开始迭代</li>
<li>item、index、array：数组元素、索引、数组本身</li>
</ul>
</li>
<li>使用示例：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = array.reduce(<span class="function">(<span class="params">sum, curent</span>) =&gt;</span> &#123;sum + current&#125;); <span class="comment">// result = 15</span></span><br></pre></td></tr></table></figure></li>
<li>注意事项：如果不指定 initial 参数，如果数组为空则会报错，所以建议<strong>始终指定初始值</strong></li>
<li><code>array.reduceRight()</code> 的遍历方向为从右至左，其余和 reduce 相同</li>
</ul>
</li>
<li><p>some() / every() 方法</p>
<ul>
<li><code>array.some(fn)</code> 类似于 <code>||</code> ，如果 fn 返回一个真值，some() 方法立刻返回 true 并停止迭代</li>
<li><code>array.every(fn)</code> 类似于 <code>&amp;&amp;</code> ，如果 fn 返回全部为真，every() 方法立刻返回 true，否则返回 false</li>
</ul>
</li>
<li><p>fill() 方法</p>
<ul>
<li><code>array.fill(value, start, end)</code>  从索引 start 到 end，用重复的 value 填充数组</li>
</ul>
</li>
</ul>
<h3 id="判断数组方法"><a href="#判断数组方法" class="headerlink" title="判断数组方法"></a>判断数组方法</h3><ul>
<li><p><code>Object.prototype.toString.call()</code></p>
<ul>
<li>每一个继承 Object 对象都有 toString 方法，<strong>如果 toString 方法没有被重写的话，会返回 <code>[Object type]</code></strong>, type 是对象的类型</li>
<li>常用于判断浏览器内置对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&quot;wujie&quot;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// &quot;[object null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// &quot;[object undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>instanceof</code></p>
<ul>
<li>内部机制是通过判断对象的原型链能否找到类型的 prototype</li>
<li>如果能够找到 Array 原型，则判断为数组 <code>instanceof Array</code></li>
<li><code>instanceof</code> 只能判断对象类型，<strong>不能判断原始类型</strong>，并且所有对象类型 <code>instanceof Object</code> 都是 <code>true</code></li>
</ul>
</li>
<li><p><code>Array.isArray()</code></p>
<ul>
<li>优于 <code>instancof</code>，<strong>因为 <code>Array.isArray</code> 可以检测出 iframs</strong></li>
<li>可以通过 <code>Object.prototype.toString.call()</code> 实现 isArray() 方法  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray()) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组方法注意事项"><a href="#数组方法注意事项" class="headerlink" title="数组方法注意事项"></a>数组方法注意事项</h3></li>
</ul>
</li>
<li><p><code>sort</code>、<code>reverse</code>、<code>splice</code> 方法修改的是数组本身</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 继承实现方式整理</title>
    <url>/2021/12/24/JS-%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ul>
<li>将子类的原型对象指向父类的实例</li>
<li>优点：继承了父类的模板，又继承了父类的原型对象</li>
<li>缺点：<ul>
<li>无法实现多继承(因为已经指定了原型对象了)</li>
<li>父类的所有 引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响</li>
<li>创建子类时，无法向父类构造函数传参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.info = &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;Parent&quot;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类的实例</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.info.gender = <span class="string">&quot;M&quot;</span>;</span><br><span class="line">child.getInfo(); <span class="comment">// &#123; name: &#x27;Parent&#x27;, age: 18, gender: &#x27;M&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><ul>
<li>在子类构造函数内部使用 <code>apply</code> 或 <code>call</code> 来调用父类构造函数，复制父类的实例属性给子类</li>
<li>优点：<ul>
<li>解决了原型链继承中子类实例共享父类引用对象的问题，实现<strong>多继承</strong></li>
<li>创建子类实例时，可以向父类传递参数</li>
</ul>
</li>
<li>缺点：<ul>
<li>构造继承只能继承父类的实例属性和方法，不能继承父类原型的属性和方法（方法属性写在构造函数中，每次创建示例都会被初始化）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.info = &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="attr">hobby</span>: [<span class="string">&quot;football&quot;</span>, <span class="string">&quot;basketball&quot;</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类属性</span></span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类方法</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">&quot;wujie1&quot;</span>, <span class="number">19</span>);</span><br><span class="line">child1.info.hobby.push(<span class="string">&quot;soccer&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getInfo()); <span class="comment">// &#123; name: &#x27;wujie1&#x27;, hobby: [ &#x27;football&#x27;, &#x27;basketball&#x27;, &#x27;soccer&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child(<span class="string">&quot;wujie2&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.getInfo()); <span class="comment">// &#123; name: &#x27;wujie2&#x27;, hobby: [ &#x27;football&#x27;, &#x27;basketball&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><ul>
<li>使用<strong>原型链继承</strong>保证子类继承父类<strong>原型</strong>的属性和方法</li>
<li>使用<strong>构造继承</strong>保证子类继承父类<strong>实例</strong>的属性和方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.info = &#123;</span><br><span class="line">		name,</span><br><span class="line">		<span class="attr">hobby</span>: [<span class="string">&quot;football&quot;</span>, <span class="string">&quot;basketball&quot;</span>],</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 继承父类属性</span></span><br><span class="line">	Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类方法</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">&quot;wujie1&quot;</span>, <span class="number">19</span>);</span><br><span class="line">child1.info.hobby.push(<span class="string">&quot;soccer&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1.getInfo()); <span class="comment">// &#123; name: &#x27;wujie1&#x27;, hobby: [ &#x27;football&#x27;, &#x27;basketball&#x27;, &#x27;soccer&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child(<span class="string">&quot;wujie2&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.getInfo()); <span class="comment">// &#123; name: &#x27;wujie2&#x27;, hobby: [ &#x27;football&#x27;, &#x27;basketball&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><ul>
<li>通过拷贝对象引用方式实现，但可能导致对象被修改<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;parent&quot;</span>,</span><br><span class="line">	<span class="attr">hobby</span>: [<span class="string">&quot;football&quot;</span>, <span class="string">&quot;basketball&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="built_in">Object</span>.create(parent);</span><br><span class="line">child.name = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">child.hobby.push(<span class="string">&quot;soccer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">// child</span></span><br><span class="line"><span class="built_in">console</span>.log(child.hobby); <span class="comment">// [ &#x27;football&#x27;, &#x27;basketball&#x27;, &#x27;soccer&#x27; ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><ul>
<li>通过获取对象的浅拷贝，再对浅拷贝方法增强（添加方法），也就是在原型式寄生的基础上再添加方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;parent&quot;</span>,</span><br><span class="line">	<span class="attr">hobby</span>: [<span class="string">&quot;football&quot;</span>, <span class="string">&quot;basketball&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(original);</span><br><span class="line">	clone.getHobby = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.hobby;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = clone(parent);</span><br><span class="line">child.name = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">child.hobby.push(<span class="string">&quot;soccer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">// child</span></span><br><span class="line"><span class="built_in">console</span>.log(child.hobby); <span class="comment">// [ &#x27;football&#x27;, &#x27;basketball&#x27;, &#x27;soccer&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(child.getHobby()); <span class="comment">// [ &#x27;football&#x27;, &#x27;basketball&#x27;, &#x27;soccer&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><ul>
<li>将组合继承，寄生式继承组合起来实现的继承，是所有继承方式的最优解</li>
<li>优点：解决了组合继承父类会被调用两次和属性在不同层级会重复的问题<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">	<span class="built_in">this</span>.hobby = [<span class="string">&quot;football&quot;</span>, <span class="string">&quot;basketball&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getHobby = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.hobby;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	Parent.call(<span class="built_in">this</span>);</span><br><span class="line">	<span class="built_in">this</span>.friend = <span class="string">&quot;child friends&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">	child.prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">	child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent, Child);</span><br><span class="line"></span><br><span class="line">Child.prototype.getFriend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.friend;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.getHobby()); <span class="comment">// [ &#x27;football&#x27;, &#x27;basketball&#x27; ]</span></span><br><span class="line">	<span class="built_in">console</span>.log(child.getFriend()); <span class="comment">// child friend</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h2><ul>
<li>通过 <code>extends</code>、<code>super</code> 实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">		<span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
