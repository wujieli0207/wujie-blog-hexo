<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/25/hello-world/</url>
    <content><![CDATA[<p>Hey wujie, 这是你发布在网络上的第一篇博客，希望你不忘初心，无限进步</p>
]]></content>
  </entry>
  <entry>
    <title>vue3个人常用通信方式总结</title>
    <url>/2021/12/06/vue3%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul>
<li><p>Vue3 子组件可以通过 props 接受父组件的传值</p>
</li>
<li><p>在 setup() 中可以通过 <code>props.value</code> 来访问父组件传值</p>
</li>
<li><p>父组件传值举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child-component :value=&quot;value&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件接受并使用父组件传递值</p>
<span id="more"></span>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&#123;&#123; fatherValue &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;ChildComponent&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const fatherValue = ref(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            fatherValue = props.value</span><br><span class="line">            console.log( fatherValue )</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                fatherValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2></li>
<li><p>通过 refs ，父组件可以直接获取子组件实例，并向子组件传值</p>
</li>
<li><p>父组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child ref=&quot;childRef&quot; /&gt;</span><br><span class="line">	&lt;button @click=&quot;sendValue()&quot;&gt;</span><br><span class="line">        Change Child Value</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;ChildComponent&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const childRef = ref(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            const sendValue = () =&gt; &#123;</span><br><span class="line">                console.log(&quot;childRef&quot;, childRef.value);</span><br><span class="line"></span><br><span class="line">                // 调用子组件方法</span><br><span class="line">                childRef.value.acceptValue(&quot;newValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                fatherValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	Son: &#123;&#123; valueRef &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;ChildComponent&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">            value: &#123;</span><br><span class="line">                type: String,</span><br><span class="line">                default: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const valueRef = ref(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            const acceptValue = (value) =&gt; &#123;</span><br><span class="line">            	valueRef.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                valueRef,</span><br><span class="line">                acceptValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="emits"><a href="#emits" class="headerlink" title="emits"></a>emits</h2><ul>
<li><p>子组件可以通过 emit 暴露属性，父组件通过 emit 暴露属性操作子组件，比如：点击子组件触发了一个父组件大函数</p>
</li>
<li><p>父亲组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;child-component :add-child=&quot;addChildMethod()&quot;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;js&quot;&gt;</span><br><span class="line">    import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">    export default defineComponent (&#123;</span><br><span class="line">        name: &quot;FatherComponent&quot;,</span><br><span class="line">        setup( props ) &#123;</span><br><span class="line">            const addChildMethod = () =&gt; &#123;</span><br><span class="line">                // mehtod</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;</span><br><span class="line">                addChildMethod</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件举例</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div @click=&quot;$emit(&#x27;addChild&#x27;)&quot;&gt;</span><br><span class="line">        &lt;!-- some --&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack入门-入口与出口</title>
    <url>/2021/12/02/webpack%E5%85%A5%E9%97%A8-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="入口及基础配置"><a href="#入口及基础配置" class="headerlink" title="入口及基础配置"></a>入口及基础配置</h2><ul>
<li>webpack 该用哪个模块作为构建依赖图的开始</li>
<li>在 <code>entry</code> 配置入口，可以指定一个或多个入口  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>单页面场景配置<ul>
<li>将应用入口和第三方库分离</li>
<li>可以使用 <code>CommonsChunkPlugin</code>  从「应用程序 bundle」中提取 vendor 引用到 vendor bundle，把引用 vendor 的部分替换为 ，<code>__webpack_require__()</code> 调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">	<span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">	<span class="attr">vendors</span>: <span class="string">&#x27;./src/vendors.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>多页面场景配置<ul>
<li>不同页面入口分开配置，进入新页面时独立加载 html 和对应引用</li>
<li>可以使用 <code>CommonsChunkPlugin</code> 为每个页面间的应用程序共享代码创建 bundle，实现代码复用的效果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">	<span class="attr">pageOne</span>: <span class="string">&#x27;./src/pageOne/index.js&#x27;</span>,</span><br><span class="line">	<span class="attr">pageTwo</span>: <span class="string">&#x27;./src/pageTwo/index.js&#x27;</span>,</span><br><span class="line">	<span class="attr">pageThree</span>: <span class="string">&#x27;./src/pageThree/index.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="出口及基础配置"><a href="#出口及基础配置" class="headerlink" title="出口及基础配置"></a>出口及基础配置</h2><ul>
<li><p>webpack 输出 bundles 的目录及命名方式配置，默认为  <code>./dist</code></p>
</li>
<li><p><strong>可以指定多个入口，但只能有一个出口（output）</strong></p>
</li>
<li><p>在 <code>output</code> 字段配置：输出为一个对象，输出路径和文件名</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">	<span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">	<span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>对于多文件入口，使用占位符保持文件名正确</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">	<span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">	<span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">	<span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure></li>
<li><p>在编译时不知道最终输出文件的 <code>publicPath</code> 的情况下，<code>publicPath</code> 留空，并且在入口起点设置 <code>__webpack_public_path__</code></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余的应用程序入口</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack入门-loader</title>
    <url>/2021/12/05/webpack%E5%85%A5%E9%97%A8-loader/</url>
    <content><![CDATA[<h2 id="loader-基础"><a href="#loader-基础" class="headerlink" title="loader 基础"></a>loader 基础</h2><ul>
<li><p>将所有文件转换成 webpack 能够处理的模块，用于处理非 JS 文件</p>
</li>
<li><p>在 module.rule 配置，必须包含 test 和 use 属性</p>
<ul>
<li><code>test</code>： 标识出应该被对应的 loader 进行转换的某个或某些文件</li>
<li><code>use</code>：进行转换时，应该使用哪个 loader<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">	<span class="attr">rules</span>: [</span><br><span class="line">	  &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: <span class="string">&#x27;css-loader&#x27;</span> &#125;,</span><br><span class="line">	  &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, use: <span class="string">&#x27;ts-loader&#x27;</span> &#125;</span><br><span class="line">	]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用 loader 的三种方式</p>
<ul>
<li>配置（推荐）：在 webpack.config.js 中配置</li>
<li>内联：在每个 import 语句中显式指定 loader<br>  <code>import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;;</code></li>
<li>CLI：在 shell 命令中指定它们<br>  <code>webpack --module-bind jade-loader --module-bind &#39;css=style-loader!css-loader&#39;</code></li>
</ul>
</li>
<li><p>loader 特性</p>
<ul>
<li>loader 支持链式传递，反向执行，loader 链中的第一个 loader 返回值给下一个 loader</li>
<li>loader 可同步也可异步</li>
<li>loader 可以在 Node.js 环境运行</li>
<li>loader 能够接受查询参数</li>
<li>loader 可以使用 <code>opotions</code> 对象进行配置</li>
<li>可以将普通 npm 模块导出一个 loader</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
